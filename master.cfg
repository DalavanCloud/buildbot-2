# ex: set ft=python:
##############################################################################
# Name:       master.cfg
# Purpose:    Buildbot configuration for wxWidgets
# Created:    Mar 15 2007
# Copyright:  (c) 2007 Mike Wetherell
#             (c) 2015 Vadim Zeitlin
# Licence:    wxWidgets licence
##############################################################################

# Define the dictionary used by buildmaster and its usual alias.
c = BuildmasterConfig = {}

buildmaster_email = "vadim@wxwidgets.org"

####### BUILD SLAVES

from buildbot.buildslave import BuildSlave
c["slaves"] = []

# The passwords are in a separate file to keep them secret.
try:
    execfile("passwd.cfg")
except:
    raise RuntimeError("Error reading slave table")

for s in slaves.items():
    c["slaves"].append(BuildSlave(s[0], s[1],
                       notify_on_missing=buildmaster_email))

# Only listen on localhost interface as all connections go through stunnel.
c["slavePortnum"] = "tcp:9989:interface=127.0.0.1"

####### CHANGE SOURCES

# Currently none, Github notifies us using a web hook, see status target
# configuration below.

####### BUILDERS

from buildbot.process import factory
from buildbot.steps.shell import ShellCommand,Compile
c["builders"] = []

quick_builders = {"master": [], "WX_3_0_BRANCH": []}
full_builders = {"master": [], "WX_3_0_BRANCH": []}

# Helpers for constructing the build steps used below.

# m must be either "incremental" or "full"
def checkout_step(br, m):
    from buildbot.steps.source.git import Git
    return Git(
        repourl="https://github.com/wxWidgets/wxWidgets.git",
        branch=br,
        mode=m,
    )

def configure_step(config_args=[]):
    from buildbot.steps.shell import Configure
    return Configure(
        command="./configure %s" % ' '.join(config_args)
    )

def build_step(what, **kwargs):
    return Compile(
        name="build " + what,
        description=["building", what],
        descriptionDone=[what],
    )

def build_libraries_step():
    return build_step("libraries")

def build_programs_step():
    return build_step("programs",
        command="(cd samples && make) && (cd utils && make)",
        haltOnFailure=False,
    )

def build_tests_step():
    return build_step("tests",
        workdir="build/tests",
    )

def run_tests_step(cmd="./test -t", **kwargs):
    return ShellCommand(
        name="test",
        workdir="build/tests",
        command=cmd,
        warnOnFailure=True,
        description=["running", "tests"],
        descriptionDone=["tests"],
        **kwargs
    )

# cmd is the command used to actually run the GUI test.
def run_gui_tests_step(cmd, **kwargs):
    return ShellCommand(
        name="GUI test",
        workdir="build/tests",
        command=cmd,
        warnOnFailure=True,
        description=["running", "GUI", "tests"],
        descriptionDone=["GUI", "tests"],
        **kwargs
    )

def do_make_unix_like_factory(branch, config_args, mode, run_gui_test_cmd):
    return factory.BuildFactory([
        checkout_step(branch, mode),
        configure_step(config_args),
        build_libraries_step(),
        build_programs_step(),
        build_tests_step(),
        run_tests_step(),
        run_gui_tests_step(run_gui_test_cmd)
    ])

def make_unix_factory(branch="master", config_args=[], mode="incremental"):
    return do_make_unix_like_factory(
        branch, config_args, mode, "./test_gui -t"
    )

def make_osx_factory(branch="master", config_args=[], mode="incremental"):
    return do_make_unix_like_factory(
        branch, config_args, mode, "./test_gui.app/Contents/MacOS/test_gui -t"
    )

def make_ios_factory(branch="master", mode="incremental"):
    config_args=["--with-osx_iphone",
                 "--enable-monolithic",
                 "--with-macosx-version-min=7.1",
                 "--with-macosx-sdk=$(xcrun --sdk iphonesimulator --show-sdk-path)",
                ]

    # Don't build any programs for iOS, this doesn't work currently.
    return factory.BuildFactory([
        checkout_step(branch, mode),
        configure_step(config_args),
        build_libraries_step(),
    ])

def build_nmake_step(what, makedir, **kwargs):
    return Compile(
        name=what,
        workdir=r"build\%s" % makedir,
        command=["nmake",
                 "/nologo",
                 "/f", "makefile.vc",
                 "BUILD=release",
                 "SHARED=1",
                ],
        description=["building", what],
        descriptionDone=[what],
        **kwargs
    )

# This is only available in full mode as nmake is incapable of detecting
# header dependencies and so can't be used for quick rebuilds.
def make_nmake_factory(branch="master"):
    # Make sure the DLLs are found when running tests.
    tests_env={"PATH": [r"..\lib\vc_dll", "${PATH}"]}

    return factory.BuildFactory([
        checkout_step(branch, "full"),
        build_nmake_step("libraries", r"build\msw"),
        build_nmake_step("samples", r"samples",
            haltOnFailure=False,
        ),
        build_nmake_step("tests", r"tests"),
        run_tests_step(r"vc_mswudll\test.exe -t", env=tests_env),
        run_gui_tests_step(r"vc_mswudll\test_gui.exe -t", env=tests_env)
    ])

# This must be used to create builders descriptions: not only it ensures that
# they have consistent names and build directories, but it also adds the name
# of the new builder to one of xxx_builder_names arrays so that all builders
# are part of one of them and so are associated with the right scheduler.
def make_build_desc(branch, port, platform="", full=False):
    n = ""
    d = "builds/"

    if branch == "master":
        d += "master"
    elif branch == "WX_3_0_BRANCH":
        d += "wx30"
        n += "3.0-"
    else:
        raise "Unknown branch " + branch

    n += port
    d += "_" + port[2:].replace("-", "_").lower() # Discard "wx" prefix.

    if platform != "":
        n += "-" + platform
        d += "_" + platform.replace("-", "_").lower()

    if full:
        n += "-full"
        d += "_full"
        full_builders[branch].append(n)
    else:
        quick_builders[branch].append(n)

    return {"name": n, "builddir": d}


# Map platforms to the slaves using them.
slave_for = {
        "Linux-i686":    "brandt32",
        "Linux-x86_64":  "brandt64",
    }

# Set up Linux builds done on both master and 3.0 branches.
for br in ["master", "WX_3_0_BRANCH"]:
    # The same wxGTK builds are done on a couple of different platforms.
    for pl in ["Linux-i686", "Linux-x86_64"]:
        if br == "master":
            disable_compat_arg="--disable-compat30"
        elif br == "WX_3_0_BRANCH":
            disable_compat_arg="--disable-compat28"
        else:
            raise "Unknown branch " + br

        build = make_build_desc(br, "wxGTK-STL", pl)
        build.update({
                "slavename": slave_for[pl],
                "factory": make_unix_factory(
                    branch=br,
                    config_args=["--enable-stl", disable_compat_arg]
                ),
            })
        c["builders"].append(build)

        build = make_build_desc(br, "wxGTK", pl, full=True)
        build.update({
                "slavename": slave_for[pl],
                "factory": make_unix_factory(br, mode="full"),
            })
        c["builders"].append(build)

# Set up OS X builds: things are more complicated here as they don't use the
# same options with master and 3.0.

osx_args_32_only = ["--enable-macosx_arch=i386"]
osx_args_64_only = ["--enable-macosx_arch=x86_64"]
osx_args_min_10_5 = ["--with-macosx-version-min=10.5",
                     "--with-macosx-sdk=/Developer/SDKs/MacOSX10.6.sdk",
                     "--with-cppunit-prefix=/Developer/libstdc++variants/cppunit",
                    ] + osx_args_32_only
osx_args_min_10_7 = ["--with-macosx-version-min=10.7",
                     "--with-cppunit-prefix=/Developer/libstdc++variants/cppunit",
                    ]
osx_args_min_10_9 = ["--with-macosx-version-min=10.9",
                     "--with-cppunit-prefix=/Developer/libc++variants/cppunit",
                    ]

build = make_build_desc("master", "wxOSX-Cocoa")
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            config_args=osx_args_min_10_9 + osx_args_64_only,
        ),
    })
c["builders"].append(build)

build = make_build_desc("master", "wxOSX-Cocoa-10.7", full=True)
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            config_args=osx_args_min_10_7,
            mode="full"
        ),
    })
c["builders"].append(build)

build = make_build_desc("master", "wxiOS", full=True)
build.update({
        "slavename": "csleobuild",
        "factory": make_ios_factory(mode="full"),
    })
c["builders"].append(build)

build = make_build_desc("WX_3_0_BRANCH", "wxOSX-Cocoa-10.5")
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            branch="WX_3_0_BRANCH",
            config_args=osx_args_min_10_5,
        ),
    })
c["builders"].append(build)

build = make_build_desc("WX_3_0_BRANCH", "wxOSX-Cocoa-10.5", full=True)
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            branch="WX_3_0_BRANCH",
            config_args=osx_args_min_10_5,
            mode="full"
        ),
    })
c["builders"].append(build)

build = make_build_desc("WX_3_0_BRANCH", "wxOSX-Carbon")
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            branch="WX_3_0_BRANCH",
            config_args=["--with-osx_carbon"] + osx_args_min_10_5,
        ),
    })
c["builders"].append(build)

# Set up MSW builds.
build = make_build_desc("master", "wxMSW-VC8", full=True)
build.update({
        "slavename": "disc-xp",
        "factory": make_nmake_factory(),
    })
c["builders"].append(build)

build = make_build_desc("WX_3_0_BRANCH", "wxMSW-VC8", full=True)
build.update({
        "slavename": "disc-xp",
        "factory": make_nmake_factory(),
    })
c["builders"].append(build)

####### SCHEDULERS

c["schedulers"] = []

from buildbot.schedulers.basic import SingleBranchScheduler
c["schedulers"].append(SingleBranchScheduler(
        name="quick_master",
        branch="master",
        treeStableTimer=2*60,
        builderNames=quick_builders["master"],
    ))

c["schedulers"].append(SingleBranchScheduler(
        name="quick_wx30",
        branch="WX_3_0_BRANCH",
        treeStableTimer=2*60,
        builderNames=quick_builders["WX_3_0_BRANCH"],
    ))

from buildbot.schedulers import timed
c["schedulers"].append(timed.Nightly(
        name="full_master",
        branch="master",
        builderNames=full_builders["master"],
        hour=3, minute=17,
        onlyIfChanged=True,
    ))

c["schedulers"].append(timed.Nightly(
        name="full_wx30",
        branch="WX_3_0_BRANCH",
        builderNames=full_builders["WX_3_0_BRANCH"],
        hour=5, minute=43,
        onlyIfChanged=True,
    ))

from buildbot.schedulers.forcesched import *
c["schedulers"].append(ForceScheduler(
        name="force",
        builderNames=quick_builders["master"] +
                     quick_builders["WX_3_0_BRANCH"] +
                     full_builders["master"] +
                     full_builders["WX_3_0_BRANCH"],
    ))

####### STATUS TARGETS

c["status"] = []

# Define public read-only web status endpoint that also supports a change hook
# used by Github to report the changes to the code.
from buildbot.status import html
c["status"].append(
        html.WebStatus(
            http_port=8010,
            allowForce=False,
            change_hook_dialects={
                "github": {
                    "strict": True,
                    "secret": github_secret,
                }
            },
        )
    )

# And also a protected (by HTTP authentication) endpoint allowing to force
# things.
c["status"].append(html.WebStatus(http_port=8011, allowForce=True))

# This allows to run "buildbot statuslog --master localhost:8012" to view
# buildbot activity on stdout.
from buildbot.status.client import PBListener
c["status"].append(PBListener(8012))

from buildbot.status import mail
c["status"].append(mail.MailNotifier(fromaddr="buildbot@wxwidgets.org",
                                     extraRecipients=[buildmaster_email],
                                     mode="problem"))

####### PROJECT IDENTITY

c["projectName"] = "wxWidgets"
c["projectURL"] = "http://www.wxwidgets.org"
c["buildbotURL"] = "http://buildbot.tt-solutions.com/wx/"
