# ex: set ft=python:
##############################################################################
# Name:       master.cfg
# Purpose:    Buildbot configuration for wxWidgets
# Created:    Mar 15 2007
# Copyright:  (c) 2007 Mike Wetherell
#             (c) 2015 Vadim Zeitlin
# Licence:    wxWidgets licence
##############################################################################

# Define the dictionary used by buildmaster and its usual alias.
c = BuildmasterConfig = {}

buildmaster_email = "vadim@wxwidgets.org"

####### BUILD SLAVES

from buildbot.buildslave import BuildSlave
c["slaves"] = []

# The passwords are in a separate file to keep them secret.
try:
    execfile("passwd.cfg")
except:
    raise RuntimeError("Error reading slave table")

for s in slaves.items():
    c["slaves"].append(BuildSlave(s[0], s[1],
                       notify_on_missing=buildmaster_email))

# Only listen on localhost interface as all connections go through stunnel.
c["slavePortnum"] = "tcp:9989:interface=127.0.0.1"

####### CHANGE SOURCES

# Currently none, Github notifies us using a web hook, see status target
# configuration below.

####### BUILDERS

from buildbot.process import factory
from buildbot.steps.shell import ShellCommand,Compile
c["builders"] = []

inc_builder_names = []
full_builder_names = []

# Helpers for constructing the build steps used below.

# m must be either "incremental" or "full"
def checkout_step(br, m):
    from buildbot.steps.source.git import Git
    return Git(
        repourl="https://github.com/wxWidgets/wxWidgets.git",
        branch=br,
        mode=m,
    )

def configure_step(config_args=[]):
    from buildbot.steps.shell import Configure
    return Configure(
        command="./configure %s" % ' '.join(config_args)
    )

def build_step():
    return Compile(
        name="build libraries",
        description=["building", "libraries"],
        descriptionDone=["built", "libraries"],
    )

def build_tests_step():
    return Compile(
        name="build tests",
        workdir="tests",
        description=["building", "tests"],
        descriptionDone=["built", "tests"],
    )

# cmd is the command used to actually run the tests
def run_tests_step(cmd):
    return ShellCommand(
        name="test",
        command=cmd,
        description=["running", "tests"],
        descriptionDone=["run", "tests"],
    )

def make_unix_factory(branch="master", config_args=[], mode="incremental"):
    return factory.BuildFactory([
        checkout_step(branch, mode),
        configure_step(config_args),
        build_step(),
        build_tests_step(),
        run_tests_step("cd tests && ./test -t && ./test_gui -t")
    ])

def make_osx_factory(branch="master", config_args=[], mode="incremental"):
    return factory.BuildFactory([
        checkout_step(branch, mode),
        configure_step(config_args),
        build_step(),
        build_tests_step(),
        run_tests_step(
            "export DYLD_LIBRARY_PATH=../lib && " +
            "cd tests && " +
            "./test -t && " +
            "open ./test_gui.app"
        )
    ])

# This must be used to create builders descriptions: not only it ensures that
# they have consistent names and build directories, but it also adds the name
# of the new builder to either inc_builder_names or full_builder_names so that
# all builders are part of one or the other and so are associated with the
# appropriate scheduler.
def make_build_desc(branch, port, platform="", full=False):
    d = "builds/"
    n = port

    if branch == "master":
        d += "master"
    elif branch == "WX_3_0_BRANCH":
        d += "wx30"
        n += "-3.0"
    else:
        raise "Unknown branch " + branch

    # Discard "wx" prefix.
    d += "_" + port[2:].lower()

    if platform != "":
        n += "-" + platform
        d += "_" + platform.replace("-", "_").lower()

    if full:
        n += "-full"
        d += "_full"
        full_builder_names.append(n)
    else:
        inc_builder_names.append(n)

    return {"name": n, "builddir": d}


# Map platforms to the slaves using them.
slave_for = {
        "Linux-i686":    "brandt32",
        "Linux-x86_64":  "brandt64",
    }

# Set up Linux builds done on both master and 3.0 branches.
for br in ["master", "WX_3_0_BRANCH"]:
    # The same wxGTK builds are done on a couple of different platforms.
    for pl in ["Linux-i686", "Linux-x86_64"]:
        build = make_build_desc(br, "wxGTK", pl)
        build.update({
                "slavename": slave_for[pl],
                "factory": make_unix_factory(br),
            })
        c["builders"].append(build)

        if br == "master":
            disable_compat_arg="--disable-compat30"
        elif br == "WX_3_0_BRANCH":
            disable_compat_arg="--disable-compat28"
        else:
            raise "Unknown branch " + br

        build = make_build_desc(br, "wxGTK-STL", pl)
        build.update({
                "slavename": slave_for[pl],
                "factory": make_unix_factory(
                    branch=br,
                    config_args=["--enable-stl", disable_compat_arg]
                ),
            })
        c["builders"].append(build)

# Set up OS X builds: things are more complicated here as they don't use the
# same options with master and 3.0.

osx_args_32_only = ["--enable-macosx_arch=i386"]
osx_args_64_only = ["--enable-macosx_arch=x86_64"]
osx_args_min_10_5 = ["--with-macosx-version-min=10.5",
                     "--with-macosx-sdk=/Developer/SDKs/MacOSX10.6.sdk",
                     "--with-cppunit-prefix=/Developer/libstdc++variants/cppunit",
                    ]
osx_args_min_10_7 = ["--with-macosx-version-min=10.7",
                     "--with-cppunit-prefix=/Developer/libstdc++variants/cppunit",
                    ]
osx_args_min_10_9 = ["--with-macosx-version-min=10.9",
                     "--with-cppunit-prefix=/Developer/libc++variants/cppunit",
                    ]

build = make_build_desc("master", "wxOSX-Cocoa")
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            config_args=osx_args_min_10_9 + osx_args_64_only,
        ),
    })
c["builders"].append(build)

build = make_build_desc("master", "wxOSX-Cocoa-10.7", full=True)
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            config_args=osx_args_min_10_7,
            mode="full"
        ),
    })
c["builders"].append(build)

build = make_build_desc("master", "wxiOS", full=True)
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            config_args=["--with-osx_iphone",
                         "--enable-monolithic",
                         "--with-macosx-version-min=7.1",
                         "--with-macosx-sdk=$(xcrun --sdk iphonesimulator --show-sdk-path)",
                        ],
            mode="full"
        ),
    })
c["builders"].append(build)

build = make_build_desc("WX_3_0_BRANCH", "wxOSX-Cocoa-10.5")
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            config_args=osx_args_min_10_5 + osx_args_32_only,
        ),
    })
c["builders"].append(build)

build = make_build_desc("WX_3_0_BRANCH", "wxOSX-Cocoa-10.5", full=True)
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            config_args=osx_args_min_10_5,
            mode="full"
        ),
    })
c["builders"].append(build)

build = make_build_desc("WX_3_0_BRANCH", "wxOSX-Carbon")
build.update({
        "slavename": "csleobuild",
        "factory": make_osx_factory(
            config_args=["--with-osx_carbon"] + osx_args_min_10_5,
        ),
    })
c["builders"].append(build)

####### SCHEDULERS

from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers.forcesched import *
from buildbot.schedulers import timed
c["schedulers"] = []

c["schedulers"].append(SingleBranchScheduler(
        name="quick_master",
        branch="master",
        treeStableTimer=2*60,
        builderNames=inc_builder_names,
    ))

c["schedulers"].append(timed.Nightly(
        name="dist",
        branch="master",
        builderNames=full_builder_names,
        hour=5, minute=43,
        onlyIfChanged=True,
    ))

c["schedulers"].append(ForceScheduler(
        name="force",
        builderNames=inc_builder_names + full_builder_names,
    ))

####### STATUS TARGETS

c["status"] = []

# Define public read-only web status endpoint that also supports a change hook
# used by Github to report the changes to the code.
from buildbot.status import html
c["status"].append(
        html.WebStatus(
            http_port=8010,
            allowForce=False,
            change_hook_dialects={"github": True},
            # change_hook_auth=["file:changehook.passwd"]
        )
    )

# And also a protected (by HTTP authentication) endpoint allowing to force
# things.
c["status"].append(html.WebStatus(http_port=8011, allowForce=True))

# This allows to run "buildbot statuslog --master localhost:8012" to view
# buildbot activity on stdout.
from buildbot.status.client import PBListener
c["status"].append(PBListener(8012))

from buildbot.status import mail
c["status"].append(mail.MailNotifier(fromaddr="buildbot@wxwidgets.org",
                                     extraRecipients=[buildmaster_email],
                                     mode="problem"))

####### PROJECT IDENTITY

c["projectName"] = "wxWidgets"
c["projectURL"] = "http://www.wxwidgets.org"
c["buildbotURL"] = "http://buildbot.tt-solutions.com/wx/"
